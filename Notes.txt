readline =>> lit une ligne depuis le teminal, et la retourne dans une string allouee
	     en retirant le '\n' de fin.
	prototype => char *readline (const char *prompt);
	return => string allouee ou NULL si rien a lire

rl_clear_history =>> clear l'historique readline
	prototype => void    rl_clear_history();
	return => //

rl_on_new_line =>> place le curseur sur une nouvelle ligne (touche entree)
	prototype => int     rl_on_new_line();

rl_replace_line =>> remplace la ligne actuel par celle passee en parametre (recuperer l'historique ave les fleches)
	prototype => int     rl_replace_line(str text, int clear_undo = 0);
	return => 0, -1 s'il echoue

rl_redisplay =>> affiche le contenu de rl_line_buffer a l'ecran
	prototype => void    rl_redisplay();
	return => //

add_history =>> ajoute la string en parametre a l'historique readline
	prototype => void    add_history(str string);
	return => //

printf //
malloc //
free //
write //
access =>> verifie s'il peut acceder  au fichier pathname, 
	prototype => int access(const char *pathname, int mode);
	option pour mode == F_OK si le fichier existe
			    R_OK la lecture du fichier
			    W_OK l'écriture du fichier
			    X_OK l'exécution du fichier
	les 3 derniers peuvent etre cumules avec des pipes "|"
	return => 0, -1 s'il echoue

open =>> ouvre un fichier et retourne le fd de ce fichier
	prototype => int open(const char *pathname, int flags);
		     option courante pour le flag : O_RDONLY, O_WRONLY ou O_RDWR
	return => le fd, -1 s'il echoue

read =>> lit jusqu'à n octets depuis le fd dans le buffer pointé par buf
	prototype => ssize_t read(int fd, void *buf, size_t n);
	return => le nombre d'octets lus, -1 s'il echoue

close =>> ferme le fd passe en parametre
	prototype => int close(int fd);
	return => 0, -1 s'il echoue

fork =>> creer un processus enfant, qui est une copie du processus parent(le processus depuis lequel est appele fork)
	prototype => pid_t fork(void);
	return => pid de l'enfant, 0 si on est dans l'enfant et un nombre negatif en cas d'erreur

wait =>> attend que le processus enfant se termine avant de poursuivre l'execussion, stocke dans status 
	 la valeur de retour du processus enfant(exit())
	 le système d'exploitation envoie un signal SIGCHLD au processus parent pour lui indiquer que le processus
	 enfant s'est terminé. peut également être utilisée pour récupérer des informations sur la terminaison
	 du processus enfant.
	 Les informations sont stockées dans une structure de données appelée struct wait, qui contient des
	 informations telles que le PID du processus enfant, le code de sortie et des indicateurs pour indiquer
	 la manière dont le processus enfant a été terminé.
	prototype => pid_t wait(int *status);
	return => pid de l'enfant, -1 s'il echoue (perror)

waitpid =>> fonctionne comme wait sauf que l'on precise le pid de l'enfant que l'on attend et de precise des
	    options sur le comportement dans des cas specifique
	prototype => pid_t waitpid(pid_t pid, int *status, int options);
	return => pid de l'enfant, -1 s'il echoue (perror)

wait3 =>> ancienne version de waitpid(), obsolete aujourd'hui

wait4 =>> ancienne version de waitpid(), obsolete aujourd'hui

signal =>> ancienne version de sigaction, obsolete aujourd'hui

sigaction =>> permet de modifier/creer le comportement a adopter a la reception du signal signum
	prototype => int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
	return => 0, -1 s'il echoue (perror)

sigemptyset =>> permet de vider un ensemble de signaux prealablement initialiser dans une structure sigset_t
	prototype => int sigemptyset(sigset_t *set);
	return => 0, -1 s'il echoue

sigaddset =>> permet d'ajouter un signal(signum) a un ensemble de signaux(set)
	prototype => int sigaddset(sigset_t *set, int signum);
	return => 0, -1 s'il echoue 

kill =>> permet d'envoyer un signal(sig) a un process(pid)
	prototype => int kill(pid_t pid, int sig);
	return => 0, -1 s'il echoue

exit =>> permet de quitter un programme en retournant status 
	prototype => void	exit(int status);
	return => //

getcwd =>> permet d'obtenir le chemin absolu du repertoire courant dans buf(de taille size)
	prototype => char *getcwd(char *buf, size_t size);
	return => un pointeur vers une string qui contient le path (perror))

chdir =>> permet de remplacer le repertoire courant par celui passe en parametre (pour le processus ainsi que
	  tous ses enfants)
	prototype => int chdir(const char *path);
	return => 0, -1 s'il echoue (perror)

stat =>> permet d'obtenir des informations sur le fichier/dossier path(chemin absolu ou relatif), ses informations
	 seront stoke dans la structure pointee par buf
	prototype => int stat(const char *path, struct stat *buf);
	return => 0, -1 s'il echoue (perror)

lstat =>> meme comportement que stat mais pour les liens symbolique
	prototype => int lstat(const char *path, struct stat *buf);
	return => 0, -1 s'il echoue (perror)

fstat =>> meme comportement que stat mais prend un fd en parametre
	prototype => int fstat(const char *path, struct stat *buf);
	return => 0, -1 s'il echoue (perror)

unlink =>> permet de supprimer un fichier 
	prototype => int unlink(const char *path);
	return => 0, -1 s'il echoue (perror)

execve =>> permet d'executer le programme filename(path de l'executable), avec les arguments **argv et les 
	   variables d'environnement **envp
	prototype => int execve(const char *filename, char *const argv[], char *const envp[]);
	return => -1 s'il echoue (perror)

dup =>> duplique un fd 
	prototype => int dup(int oldfd);
	return => nouveau fd, -1 s'il echoue (perror)

dup2 =>> duplique un oldfd sur newfd
	prototype => int dup2(int oldfd, int newfd);
	return => nouveau fd, -1 s'il echoue (perror)

pipe =>> permet de creer 2 fd, un qui ecrit dans le pipe et un qui lit dans le pipe, souvent utilise avec
	 dup 2 pour rediriger les entrees/sorties de processus
	prototype => int pipe(int pipefd[2]);
	return => 0, -1 s'il echoue (perror)

opendir =>> ouvre le repertoire contenu dans path 
	prototype => DIR *opendir(const char *path);
	return => un pointeur vers une structure DIR, NULL s'iil echoue (perror)

readdir =>> apres un opendir() permet de stocker les infos de la prochaine entree du repertoire dans une structure dirent
	prototype => struct dirent *readdir(DIR *dirp);
	return => un pointeur vers une structure dirent, NULL en cas d'erreur ou si la fin du repertoire (perror)

closedir =>> apres un opendir() permet de fermer le repertoire
	prototype => int closedir(DIR *dirp);
	return => 0, -1 s'il echoue (perror)

strerror =>> return une string qui decrit l'erreur en fonction de l'int passe en parametre
	prototype => char *strerror(int errnum);
	return => la string qui correspond a l'int passe en parametre ou une chaine vide si errnum = 0;

perror =>> print une information d'erreur sur la sortie standard, soit la string passe en parametre soit la
	   descripton de la derniere erreur d'une fonction systeme 
	prototype => void perror(const char *s);
	return => //

isatty =>> determine si le fd passe en parametre est un terminal
	prototype => int isatty(int fd);
	return => 1, 0 si ce n'est pas un terminal

ttyname =>> retourne une string contenant le nom du terminal associer au fd passe en parametre
	prototype => char *ttyname(int fd);
	return => nom du terminal, un pointeur NULL si le fd n'est pas associe a un terminal

ttyslot =>> determine le numero de l'entree dans la table des terminaux du terminal associe a l'entree standard
	prototype => int ttyslot();
	return => slot du terminal

ioctl =>> permet de configurer, interroger ou modifier les parametres d'un peripherique/fichier
	prototype => int ioctl(int fd, unsigned long request, ...);
	return => depends de la request

getenv =>> permet de recuperer la valeur de la variable d'environnement passer en parametre
	prototype => char *getenv(const char *name);
	return => la variable d'environnement dans une string, NULL si elle n'existe pas

tcsetattr =>> permet de configurer les parametres d'un terminal vis a vis d'un fd avec le contenu de termios_p 
	prototype => int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
	return => depends des options

tcgetattr =>> permet de recuperer les parametres d'un terminal dans une structure termios
	prototype => int tcgetattr(int fd, struct termios *termios_p);
	return => 0, -1 s'il echoue (perror)

tgetent =>> permet de recuperer l'entree d'une base de donnee terminfo du terminal *name qui sera stocker dans bp 
	prototype => int tgetent(char *bp, const char *name);
	return => 1 si ok, 0 si pas d'entree existante, -1 en cas d'erreur (perror)

tgetflag =>> tgetent necessaire avant d'utiliser tgetflag, permet de recuperer la valeur du drapeau booleen(name)
	     specife dans l'entree de base de donnee terminfo
	prototype => int tgetflag(const char *name);
	return => 1 si le flag est actif pour le terminal courant, 0 si il est desactive ou n'existe pas (perror)

tgetnum =>>  tgetent necessaire avant d'utiliser tgetnum, permet de recuperer la valeur de la capacite numerique(name)
	     specife dans l'entree de base de donnee terminfo
	prototype => int tgetnum(const char *name);
	return => la valeur de la capacite numerique specifiee ou -1 si elle n'est pas defini (perror)

tgetstr =>> tgetent necessaire avant d'utiliser tgetstr, permet de recuperer la valeur de la capacite de chaine 
	    specifiee(name) et le stocker dans l'espace memoire (area) qui doit etre alloue
	    specife dans l'entree de base de donnee terminfo
	prototype => char *tgetstr(const char *name, char **area);
	return => un pointeur vers la capacite de chaine specifiee, NULL si la capacite n'est pas defini

tgoto =>> permet de positionner le curseur a un endroit donner, prend la colonne et la ligne de la position du
	  curseur en parametre, cm est la valeur de retour de tgetstr
	prototype => char *tgoto(const char *cm, int col, int row);
	return => une string qui peut etre envoyer a la sortie standard pour positionner le curseur ou a la fonction
		  tputs pour envoyer le motif de controle de curseur a la sortie standard 

tputs =>> envoie une chaine de caractere a la sortie standard pour envoyer les donnes qui sortent des fonction precedente 
	prototype => int tputs(const char *str, int affcnt, int (*putfunc)(int));
	return => 0, un nbr negatif s'il echoue
